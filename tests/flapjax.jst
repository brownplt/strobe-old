/* Necessary initializers: 1
 * Variable type annotations: 5
 * Explicit undefined tests: 1
 * Ad-hoc rewrites: doNotPropagate, PQ to avoid bounded polymorphism
 *                  zip --> zip1, return obj vice array from lack of tuples
 *                  PQ: had to add placeholder functions so the constructor
 *                     init was happy...
 *                  line 240: moved aroudn while loop to allow unpacking
 *
 * Unhappy things:
 * Hacked together "Math" to work in typedjs-core.idl by defining
 * MathInterface, and then a constant Math that has that interface.
 *
 * Had to add implicit packing to assignment. dnno if that's good or not.
 *
 * Adding lots of local vars to unpack stuff
 */
var slice = function (arr, start, stop)
  :: forall a . [a], Int, Int? -> [a] {
  var i = 0, len :: Int = arr.length, r :: [a] = [];
  if( typeof stop == "undefined" ) { stop = len; }
  if( stop < 0 ) { stop = len + stop; }
  if( start < 0 ) { start = len - start; }
  if( stop < start ) { i = start; start = stop; stop = i; }
  for( i = 0; i < stop - start; i++ ) { r[i] = arr[start+i]; }
  return r;
}

// JST: We intentionally omit isEqual for the moment, since it uses runtime type
// tests to defeat abstraction created by quantification.  The type system
// could be altered to support it.

/*var isEqual = function (a,b) :: forall x . x, x -> Bool {
  return (a == b) ||
    ((((typeof(a) == 'number') && isNaN(a)) || a == 'NaN') &&
     (((typeof(b) == 'number') && isNaN(b)) || b == 'NaN'));
}*/


var forEach = function(fn,arr) :: forall a . (a -> any), [a] -> Undefined {
  for (var i = 0 ; i < arr.length; i++) {
    fn(arr[i]);
  }
}

var member = function(elt, lst) :: forall a . a, [a] -> Bool {
  for (var i = 0; i < lst.length; i++) {
    // JST: if (isEqual(lst[i], elt)) {return true;}
    if (lst[i] == elt) {return true;}
  }
  return false;
}

// JST: Variable arity
/*
var zip = function(arrays) {
  if (arrays.length == 0) return [];
  var ret = [];
  for(var i=0; i<arrays[0].length;i++) {
    ret.push([]);
    for(var j=0; j<arrays.length;j++)
      ret[i].push(arrays[j][i]);
  }
  return ret;
}
*/
//ad-hoc re-write: turn returned array into object with $0 and $1 fields
var zip1 = function(array1, array2) :: forall a b . [a], [b] ->
                                       [{$0 :: a, $1 :: b}] {
  var ret :: [{$0 :: a, $1 :: b}] = [];
  for (var i=0; i < array1.length; i++) {
    ret.push({$0: array1[i], $1: array2[i]});
  }
  return ret;
}

// JST: variable arity
/*
//map: (a * ... -> z) * [a] * ... -> [z]
var map = function (fn) {
  var arrays = slice(arguments, 1);
  if (arrays.length === 0) { return []; }
  else if (arrays.length === 1) {
    var ret = [];
    for(var i=0; i<arrays[0].length; i++) {ret.push(fn(arrays[0][i]));}
    return ret;
  }
  else {
    var ret = zip(arrays);
    var o = new Object();
    for(var i=0; i<ret.length; i++) {ret[i] = fn.apply(o,ret[i]);}
    return ret;
  }
}
*/
var map1 = function(f,src) :: forall a b . (a -> b), [a] -> [b]{
  var dest :: [b] = [ ];
  for (var i = 0; i < src.length; i++) { dest.push(f(src[i])); }
  return dest;
}


var filter = function (predFn, arr) :: forall a . (a -> Bool), [a] -> [a] {
  var res :: [a] = [];
  for (var i = 0; i < arr.length; i++) {
    if (predFn(arr[i])) { res.push(arr[i]); }
  }
  return res;
}

// JST: Variable arity
/*
//fold: (a * .... * accum -> accum) * accum * [a] * ... -> accum
//fold over list(s), left to right
var fold = function(fn, init) {
  var lists = slice(arguments, 2);
  if (lists.length === 0) { return init; }
  else if(lists.length === 1) {
    var acc = init;
    for(var i = 0; i < lists[0].length; i++) {
      acc = fn(lists[0][i],acc);
    }
    return acc;
  }
  else {
    var acc = init;
    for (var i = 0; i < lists[0].length; i++) {
      var args = map( function (lst) { return lst[i];},
            lists);
      args.push(acc);
      acc = fn.apply({}, args);
    }
    return acc;
  }
};

//foldR: (a * .... * accum -> accum) * accum * [a] * ... -> accum
//fold over list(s), right to left, fold more memory efficient (left to right)
var foldR = function (fn, init) {
  var lists = slice(arguments, 2);
  if (lists.length === 0) { return init; }
  else if(lists.length === 1) {
    var acc = init;
    for(var i=lists[0].length - 1; i > -1; i--)
      acc = fn(lists[0][i],acc);
    return acc;
  }
  else {
    var acc = init;
    for (var i = lists[0].length - 1; i > -1; i--) {
      var args = map( function (lst) { return lst[i];},
            lists);
      args.push(acc);
      acc = fn.apply({}, args);
    }
    return acc;
  }
};
*/

//////////////////////////////////////////////////////////////////////////////
// Flapjax core

constructor DoNotPropagate() :: -> {} {
}
var doNotPropagate = new DoNotPropagate();
constructor Pulse(stamp, value) :: forall p . Int, p
                                -> { stamp :: Int, readonly value :: p }
{
  // Timestamps are used by liftB (and ifE). Since liftB may receive multiple
  // update signals in the same run of the evaluator, it only propagates the
  // signal if it has a new stamp.
  this.stamp = stamp;
  this.value = value;
}

var lastRank = 0;
//the updater function takes a function and a node and does stuff..?
constructor EventStream(nodes, updater)
 :: forall x y .
      [exists z . EventStream[z, x]:],
      (this :: EventStream[x,y]:,
       (Pulse[x]: -> Undefined), Pulse[x]: -> U(DoNotPropagate:, Pulse[y]:))
 -> { sendsTo :: [exists z. EventStream[y, z]:],
      rank :: Int,
      updater :: (this :: EventStream[x,y]:,
                  (Pulse[x]: -> Undefined),
                   Pulse[x]: -> U(DoNotPropagate:, Pulse[y]:))
    }
{
 this.updater = updater;
 this.sendsTo = []; // forward link
 this.rank = 0;

 for (var i = 0; i < nodes.length; i++) {
   var ni :: unpack a = nodes[i];
   ni.sendsTo.push(this);
 }

 this.rank = ++lastRank;
}

constructor PQ() :: -> {
  insert :: (this :: PQ:, (exists x z . {
                             k :: Int,
                             n :: EventStream[x, z]:,
                             v :: Pulse[x]:}) -> Undefined),
  isEmpty :: (this :: PQ: -> Bool),
  pop :: (this :: PQ:, ->  (exists x z . {
                             k :: Int,
                             n :: EventStream[x, z]:,
                             v :: Pulse[x]:})),
  val :: [(exists x z . {
             k :: Int,
             n :: EventStream[x, z]:,
             v :: Pulse[x]:})]
}
{
  //placeholders:
  this.val = [];
  this.insert = function (b) :: (this :: PQ:, (exists x z . {
                             k :: Int,
                             n :: EventStream[x, z]:,
                             v :: Pulse[x]:}) -> Undefined) {};
  this.isEmpty = function () :: (this :: PQ:, -> Bool) { return true; }
  this.pop = function () :: (this :: PQ:, -> (exists x z . {
                             k :: Int,
                             n :: EventStream[x, z]:,
                             v :: Pulse[x]:})) { return this.val[0]; }

  //now the real functions:
  var ctx = this;
  this.insert = function (kv_) :: (this :: PQ:, (exists x z . {
                   k :: Int,
                   n :: EventStream[x, z]:,
                   v :: Pulse[x]:}) -> Undefined) {
    var kv :: unpack x1 z1 = kv_;
    ctx.val.push(kv);
    var kvpos = ctx.val.length - 1;

    while (1) {
      var midval :: unpack x2 z2 = ctx.val[Math.floor((kvpos-1)/2)];
      if (!(kvpos > 0 && kv.k < midval.k)) break;

      var oldpos = kvpos;
      kvpos = Math.floor((kvpos-1)/2);
      ctx.val[oldpos] = ctx.val[kvpos];
      ctx.val[kvpos] = kv;
    }
  };
  this.isEmpty = function () :: (this :: PQ:, -> Bool) {
    return ctx.val.length === 0;
  }

  this.pop = function () :: (
               this :: PQ:, -> (
                 exists x z . {
                   k :: Int,
                   n :: EventStream[x, z]:,
                   p :: Pulse[x]:})) {
    if(ctx.val.length == 1) {
      var val :: unpack a b = ctx.val.pop();
      return val; //ctx.val.pop();
    }
    var ret = ctx.val.shift();
    ctx.val.unshift(ctx.val.pop());
    var kvpos = 0;
    var kv :: unpack a0 b0 = ctx.val[0];
    while(1) {
      var kvp1 :: unpack ap1 bp1 = ctx.val[kvpos*2+1];
      var kvp2 :: unpack ap2 bp2 = ctx.val[kvpos*2+2];

      var leftChild = (kvpos*2+1 < ctx.val.length
                       ? kvp1.k
                       : kv.k+1);
      var rightChild = (kvpos*2+2 < ctx.val.length
                        ? kvp2.k
                        : kv.k+1);

      if(leftChild > kv.k && rightChild > kv.k)
	break;
      else if(leftChild < rightChild) {
	ctx.val[kvpos] = kvp1;   //implicit packing, here
	ctx.val[kvpos*2+1] = kv;
	kvpos = kvpos*2+1;
      }
      else {
	ctx.val[kvpos] = kvp2;
	ctx.val[kvpos*2+2] = kv;
	kvpos = kvpos*2+2;
      }
    }
    return ret;
  };
};


var stamp = 1;
var nextStamp = function () :: -> Int { return ++stamp; };

//propagatePulse: Pulse * Array Node ->
//Send the pulse to each node
var propagatePulse = function (pulse, node) ::
  forall a . Pulse[a]:, (exists z . EventStream[a,z]:) -> Undefined {
  var queue = new PQ(); //topological queue for current timestep

  queue.insert({k:node.rank,n:node,v:pulse});
  while(!(queue.isEmpty())) {
    var qv :: unpack x y = queue.pop();
    //qv.n is [x, y]
    //qv.v is [x]
    //qv.n.updater :: ((Pulse[x] -> Undefined), Pulse[x] -> Pulse[y])

    qv.n.updater(
      function(nextPulse) :: (Pulse[x]: -> Undefined) {
        for(var i=0; i<qv.n.sendsTo.length;i++)
          queue.insert({k:qv.n.sendsTo[i].rank,n:qv.n.sendsTo[i],v:nextPulse});
      }, new Pulse(qv.v.stamp,qv.v.value));
  }
};


/*
var currentlyPropagating = false;

var timeQueue =
  new (PQ@[{ k:: Int,
             v :: PQ[(exists x z . { p :: Pulse[x]:, n :: EventStream[x,z]: })]:
           }])();


var propagate = function(now) :: Int -> Undefined {
  // If when == now,
  if (currentlyPropagating) {
    // If when <= now, pulseQueue will be reached by the existing call to
    // propagatePulse
    return;
  }

  currentlyPropagating = true;
 // try {
    var pulseQueue_ = timeQueue.peek();
    if (pulseQueue_ && pulseQueue_.k <= now) {
      var pulseQueue  = timeQueue.pop().v;

      var len = 1;
      while (len) {
        var qv :: unpack x y = pulseQueue.pop();
        len--;
        var nextPulse :: U(DoNotPropagate:, Pulse[y]:)
              = qv.n.updater(new Pulse(qv.p.stamp, qv.p.value));

        var weaklyHeld = true;
        //should work:
        //if (nextPulse instanceof DoNotPropagate) continue;

        if ((nextPulse instanceof Pulse)) {
          for (var i = 0; i < qv.n.sendsTo.length; i++) {
            var to :: unpack z = qv.n.sendsTo[i];
            weaklyHeld = weaklyHeld && to.weaklyHeld;
            len++;
            //pulseQueue.insert(to.rank, { p: nextPulse, n: to });
            var x = { p: nextPulse, n: to };
            pulseQueue.insert(to.rank, x);
          }
          if (qv.n.sendsTo.length > 0 && weaklyHeld) {
            qv.n.weaklyHeld = true;
          }
        }
      }

      pulseQueue_ = timeQueue.peek();

    }

 // }
 // TODO: try-finally not supported yet, for no good reason
 // finally {
 //   currentlyPropagating = false;
 // }

}

*/