function (b,a) :: ((int -> int), (int -> int) ->) { a = b; } @@ succeeds;
//function sub-typing.
//a = b works iff b is a subtype of a
//co-variant return types:
function (b,a) :: ((int -> int), (int -> double) ->) { a = b; } @@ succeeds;
function (b,a) :: ((int -> double), (int -> int) ->) { a = b; } @@ fails;
function (b,a) :: ((int -> {x::string}), (int -> {}) ->) { a = b; } @@ succeeds;
function (b,a) :: ((int -> {}), (int -> {x::string}) ->) { a = b; } @@ fails;

//contra-variant arg types:
function (b,a) :: ((double -> int), (int -> int) ->) { a = b; } @@ succeeds;
function (b,a) :: ((int -> int), (double -> int) ->) { a = b; } @@ fails;
//various things w/ req args, opt args, etc:

//arrays:
function (b,a) :: (Array<int>, Array<double> ->) { a = b; } @@ succeeds;
function (b,a) :: (Array<double>, Array<int> ->) { a = b; } @@ fails;

//BAD:
function (b,a) :: (Array<int>, Array<double> ->) {
    a = b;
    a[0] = 19.43;
} @@ fails;
function (b,a) :: ({x::int,y::int}, {x::double}->) {
    a = b;
    a.x = 3.41;
} @@ fails;

//objects:
function (b,a) :: ({x::int,y::int}, {x::int}->) {
    a = b;
    a.x = 3;
} @@ succeeds;

function () :: (->) {
  var arrb :: Array<{x::int,y::int}> = [{x:5,y:6}];
  arrb[0] = {x:5};
} @@ fails;
function () :: (->) {
  var a :: {x :: int} = {x: 5};
  var arrb :: Array<{x::int,y::int}> = [{x:5}];
  a = arrb[0];
} @@ fails;