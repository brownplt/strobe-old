//debugging in typechecker:
external $printtype$ :: any ->;
external $printvp$ :: any ->;


type Object :: rec Object . {
  constructor :: (any... -> any), //super-type of all functions
  hasOwnProperty :: ([Object] string -> bool),
  isPrototypeOf :: ([Object] {} -> bool),
  propertyIsEnumerable :: ([Object] string -> bool),
  toLocaleString :: ([Object] -> string),
  toString :: ([Object] -> string),
  valueOf :: ([Object] -> any)
};

sealed type Number :: rec Number . {
  toExponential :: ([Number] int? -> string),
  toFixed :: ([Number] int? -> string),
  toPrecision :: ([Number] int? -> string),
  toString :: ([Number] -> string),
  toLocaleString :: ([Number] -> string),
    //toString is re-defined here because a TypeError results if the function
    //is called on an object that is not a string.
  valueOf :: ([Number] -> double) //should make sure this is a subtype
                                  //of object's valueOf
};

external Number_ :: {
  //static constants
  MAX_VALUE :: double,
  MIN_VALUE :: double,
  NaN :: double,
  NEGATIVE_INFINITY :: double,
  POSITIVE_INFINITY :: double
};

external Math :: {
  floor :: (double -> int),
};

type String :: rec String . {
  length :: int,
  match :: ([String] string -> Array<string>?),
  toString :: ([String] -> string)
};


type Boolean :: rec Boolean . {
  valueOf :: ([Boolean] -> bool),
  toString :: ([Boolean] -> string)
};

type RegExp :: rec RegExp . {global :: bool,
                ignoreCase :: bool,
                lastIndex :: int,
                multiline :: bool,
                source :: string,
                exec :: ([RegExp] string -> Array<string>),
                test :: ([RegExp] string -> bool)};

//conversion to boolean func (available in pJS):
external Boolean :: (any -> bool);

/*
type String :: {length :: int,
                charAt :: ,
                charCodeAt :: ,
                concat :: ,
                indexOf:: ,
                lastIndexOf :: ,
                localCompare :: ,
                match :: ,
                replace :: ,
                search :: ,
                slice :: ,
                split :: ,
                substr :: ,
                substring :: ,
                toLowerCase :: ,
                toUpperCase :: ,
*/

//'static' methods of Date:
/*external Date :: {parse :: (string -> int),
                  UTC :: (int, int, int?, int?, int?, int?, int? -> int)};*/

type Date :: rec self . {getDate :: ([self] -> int),
                         getDay :: ([self] -> int),
                         getFullYear :: ([self] -> int),
                         getHours :: ([self] -> int),
                         getMilliseconds :: ([self] -> int),
                         getMinutes :: ([self] -> int),
                         getMonth :: ([self] -> int),
                         getSeconds :: ([self] -> int),
                         getTime :: ([self] -> int),
                         getTimezoneOffset :: ([self] -> int),
                         getUTCDate :: ([self] -> int),
                         getUTCDay :: ([self] -> int),
                         //...
                         getYear :: ([self] -> int),
                         setTime :: ([self] int -> int)
                        };
external Date :: ([{...}] int?, int?, int?, int?, int?, int?, int? ~~> Date);

external isNaN :: double -> bool;


external decodeURI :: (string -> string);

external undefined :: undefined;

//hax until arrays act like objects:
external push :: forall a . Array<a>, a ->;
external sort :: forall a . Array<a>, (a, a -> int) -> Array<a>;
external Array_length :: forall a. Array<a> -> int;
external unshift :: forall a. Array<a>, a -> int; //should be varargs

//prototype:
external Array_each :: forall a. Array<a>, (a -> ) ->;



external document :: HTMLDocument;

type TimeoutID  :: int; //this should really be sealed somehow.
type IntervalID :: int; //this should really be sealed somehow.

external window :: {
  document :: HTMLDocument,

  setTimeout    :: ((any... -> any), int -> TimeoutID),
  setInterval   :: ((any... -> any), int -> IntervalID),
  clearTimeout  :: (TimeoutID ->),
  clearInterval :: (IntervalID ->),
};





//AJAX

//Prototype
external String_prototype_evalJSON :: (string, bool -> {}); //TODO: blah eval!!!
external $F :: (HTMLElement -> U(string, Array<string>));
external $Fs :: (HTMLElement -> string); //guaranteed one-string version of $F
external Object_toJSON :: (any -> string?);
external Object_toJSON2 :: (any -> string); //the always-ret-val version

//hax until [] works, also, placeholderse until DIV etc. work.
external ES :: EventStream;
external HE :: HTMLElement;
external HTAE :: HTMLTextAreaElement;
external HIE :: HTMLInputElement;

//hax until modules work. this is defined in index.html, but
//tourney.tjs uses it:
external clicks_e :: (HTMLElement -> EventStream);
//stuff in tourney that index.html uses:
external server_e :: (string, EventStream -> EventStream);
external LINK :: U(HTMLElement, string) -> HTMLElement;
external modal :: (
  HTMLElement, EventStream, int? -> EventStream);
external buttonBar :: (
  Array<string>, Array<string>, string -> { elem :: HTMLElement,
                                            clickE :: EventStream});
external panelB :: (
  EventStream, {name :: U(HTMLElement, (-> HTMLElement))}, HTMLElement ->
    Behavior);


external Date_prototype_formatRelative :: (Date -> string);
external isSuccess :: {success :: bool} -> bool;

//types that tourney uses in particular. move to top of that file
//once they can be parsed up there
//gotten from either the .tjs, or from the haskell source (Data.hs)
type AsgnT :: {
  id :: string,
  desc :: string,
  enabled :: bool,
  endtime :: int,
  singletestsuite :: bool,
  solncmd :: string,
  testcmd :: string,
  solnid :: string,
  solnlang :: string,
  testlang :: string};
type TestInfoT :: {
  time :: int,
  userid :: string,
  asgnid :: string,
  body :: string,
  status :: {
    stat :: string,
    message :: string}};
type TestStatusT :: {
  id :: string,
  status :: string,
  userid :: string,
  asgnid :: string,
  singlesuite :: string
};

type TestTuple :: {
  $0 :: string, //id
  $1 :: TestInfoT};

/*type ResponseT :: {
  success :: bool,
  result :: //arbitrary object!
};*/

/*maybe testinfot is really:
 * type TestInfoT :: {
  time :: int,
  userid :: string,
  asgnid :: string,
  singlesuite :: bool,
  status :: {
    stat :: string,
    message :: string}};
 */

