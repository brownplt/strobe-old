//every type must only include types before it
//only bool, int, string, are given. (Also, Array for now is given)
//everything in here should automatically be recursve
// it should really be all mutually recursive


//methods of Array should go here

//constructors should go here; can't do that, yet.
//we can have certain types, though:
type RegExp :: {global :: bool,
                ignoreCase :: bool,
                lastIndex :: int,
                multiline :: bool,
                source :: string,
                exec :: (string -> Array<string>),
                test :: (string -> bool)};
//all this is missing is what to do when you say "new RegExp".

type String :: rec self . {length :: int,
                match :: ([self] string -> Array<string>?)};

//conversion to boolean func (available in pJS):
external Boolean :: (any -> bool);

/*
type String :: {length :: int,
                charAt :: ,
                charCodeAt :: ,
                concat :: ,
                indexOf:: ,
                lastIndexOf :: ,
                localCompare :: ,
                match :: ,
                replace :: ,
                search :: ,
                slice :: ,
                split :: ,
                substr :: ,
                substring :: ,
                toLowerCase :: ,
                toUpperCase :: ,
*/

//'static' methods of Date:
external Date :: {parse :: (string -> int),
                  UTC :: (int, int, int?, int?, int?, int?, int? -> int)};
type Date :: rec self . {getDay :: ([self] -> int),
                         getMonth :: ([self] -> int),
                         getYear :: ([self] -> int),
                         getFullYear :: ([self] -> int),
                         getHours :: ([self] -> int),
                         getMinutes :: ([self] -> int),
                         getDate :: ([self] -> int),
                         setTime :: ([self] int -> int),
                        };
//temporary date-maker, until we have 'new':
external _MakeDate :: (-> Date);

external decodeURI :: (string -> string);

external undefined :: undefined;

//hax until arrays act like objects:
external push :: forall a . Array<a>, a ->;
external sort :: forall a . Array<a>, (a, a -> int) -> Array<a>;
external Array_length :: forall a. Array<a> -> int;
external unshift :: forall a. Array<a>, a -> int; //should be varargs

//prototype:
external Array_each :: forall a. Array<a>, (a -> ) ->;



external document :: HTMLDocument;




//stuff from flapjax, temporarily added here to make testfest work
type FlapjaxElement :: {};
external makeFJE :: (-> FlapjaxElement); //total hax

//change the following once we have *dicts* and *varargs*
/*external A :: ({className :: string, href :: string}, HTMLElement ->
               FlapjaxElement);*/
external A :: (U(HTMLElement, string)... ->
               FlapjaxElement);
//the real return types of these are more specific (namely, HTMLDivElement)
//but <- doesn't work yet, and i don't wanna copy + paste stuff.
external DIV0 :: ( -> HTMLElement);
external DIV :: (U(HTMLElement, string) -> //should be varargs
                 HTMLElement);
external DIV2 :: (U(HTMLElement, string),U(HTMLElement, string) ->
                 HTMLElement);
external DIV3 :: (U(HTMLElement, string),U(HTMLElement, string),
                  U(HTMLElement, string) ->
                 HTMLElement);
external PRE :: (U(HTMLElement, string) -> HTMLElement);

external TEXTAREA :: (U(HTMLElement, string) -> HTMLElement);

type Pulse :: {stamp :: int, value :: {}}; //value should be parametrized
type SendT :: (Pulse -> );
type UpdaterT :: (SendT, Pulse -> );

type Behavior :: {}; //fill in later

external map :: forall a b. ((a -> b), Array<a> -> Array<b>);

//external internal_e :: (Array<EventStream>? -> EventStream);

type EventStream :: rec self . {updater :: UpdaterT,
                     sendsTo :: Array<self>,
                     rank :: int,
                     lift_e :: (forall a b . ((a -> b) -> self)),
                     constant_e :: (any -> self),
                     sendEvent :: ([self] {} ->), //{} here should be 'value'
                                //not sure if sendEvent is in all eventstrems...
                     filter_e :: (forall a. ((a -> bool) -> self)),
                     startsWith :: (forall a. a -> Behavior),
                     once_e :: ( -> self )
                     };
//real definition:
/*type EventStream<a> :: rec self . {updater :: UpdaterT,
                     sendsTo :: Array<self<a>>,
                     rank :: int,
                     lift_e :: (forall b . ((a -> b) -> self<b>)),
                     constant_e :: (forall b. b -> self<b>),
                                //not sure if sendEvent is in all eventstrems...
                     filter_e :: ((a -> bool) -> self<a>),
                     startsWith :: (a -> Behavior<a>) //docs are wrong?
                     };*/

external createNode :: (Array<EventStream>, UpdaterT -> EventStream);
external receiver_e :: (-> EventStream);
external merge_e :: (Array<EventStream> -> EventStream);
//real type: (EventStream ... -> EventStream)

external extractEvent_e :: (Behavior, string -> EventStream);

external insertDomE :: (EventStream, U(string, HTMLElement), string? ->
                        EventStream); //bug in api docs: return type not given
external insertDomB :: (Behavior, U(HTMLElement, string), string? -> );

external one_e :: any -> EventStream;
//real type:
//external one_e :: forall a. a -> EventStream<a>;

//AJAX

//Prototype
external String_prototype_evalJSON :: (string, bool -> {}); //TODO: blah eval!!!
external $F :: (HTMLElement -> U(string, Array<string>));
external $Fs :: (HTMLElement -> string); //guaranteed one-string version of $F
external Object_toJSON :: (any -> string?);
external Object_toJSON2 :: (any -> string); //the always-ret-val version

//hax until [] works, also, placeholderse until DIV etc. work.
external ES :: EventStream;
external HE :: HTMLElement;
external HTAE :: HTMLTextAreaElement;
external HIE :: HTMLInputElement;

//hax until modules work. this is defined in index.html, but
//tourney.tjs uses it:
external clicks_e :: (HTMLElement -> EventStream);
//stuff in tourney that index.html uses:
external server_e :: (string, EventStream -> EventStream);
external LINK :: U(HTMLElement, string) -> HTMLElement;
external modal :: (
  HTMLElement, EventStream, int? -> EventStream);
external buttonBar :: (
  Array<string>, Array<string>, string -> { elem :: HTMLElement,
                                            clickE :: EventStream});
external panelB :: (
  EventStream, {name :: U(HTMLElement, (-> HTMLElement))}, HTMLElement ->
    Behavior);


external Date_prototype_formatRelative :: (Date -> string);
external isSuccess :: {success :: bool} -> bool;

//types that tourney uses in particular. move to top of that file
//once they can be parsed up there
//gotten from either the .tjs, or from the haskell source (Data.hs)
type AsgnT :: {
  id :: string,
  desc :: string,
  enabled :: bool,
  endtime :: int,
  singletestsuite :: bool,
  solncmd :: string,
  testcmd :: string,
  solnid :: string,
  solnlang :: string,
  testlang :: string};
type TestInfoT :: {
  time :: int,
  userid :: string,
  asgnid :: string,
  body :: string,
  status :: {
    stat :: string,
    message :: string}};
type TestStatusT :: {
  id :: string,
  status :: string,
  userid :: string,
  asgnid :: string,
  singlesuite :: string
};

type TestTuple :: {
  $0 :: string, //id
  $1 :: TestInfoT};

/*type ResponseT :: {
  success :: bool,
  result :: //arbitrary object!
};*/

/*maybe testinfot is really:
 * type TestInfoT :: {
  time :: int,
  userid :: string,
  asgnid :: string,
  singlesuite :: bool,
  status :: {
    stat :: string,
    message :: string}};
 */
