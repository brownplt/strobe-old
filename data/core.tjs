//every type must only include types before it
//only bool, int, string, are given. (Also, Array for now is given)
//everything in here should automatically be recursve
// it should really be all mutually recursive


//methods of Array should go here

//constructors should go here; can't do that, yet.
//we can have certain types, though:
type RegExp :: {global :: bool,
                ignoreCase :: bool,
                lastIndex :: int,
                multiline :: bool,
                source :: string,
                exec :: (string -> Array<string>),
                test :: (string -> bool)};
//all this is missing is what to do when you say "new RegExp".

type String :: rec self . {length :: int,
                match :: ([self] string -> Array<string>?)};

//conversion to boolean func (available in pJS):
external Boolean :: (any -> bool);

/*
type String :: {length :: int,
                charAt :: ,
                charCodeAt :: ,
                concat :: ,
                indexOf:: ,
                lastIndexOf :: ,
                localCompare :: ,
                match :: ,
                replace :: ,
                search :: ,
                slice :: ,
                split :: ,
                substr :: ,
                substring :: ,
                toLowerCase :: ,
                toUpperCase :: ,
*/

//'static' methods of Date:
external Date :: {parse :: (string -> int),
                  UTC :: (int, int, int?, int?, int?, int?, int? -> int)};
type Date :: rec self . {getDay :: ([self] -> int),
                         getMonth :: ([self] -> int),
                         getYear :: ([self] -> int),
                         getFullYear :: ([self] -> int),
                         getHours :: ([self] -> int),
                         getMinutes :: ([self] -> int),
                         getDate :: ([self] -> int),
                         setTime :: ([self] int -> int),
                        };
//temporary date-maker, until we have 'new':
external _MakeDate :: (-> Date);

external decodeURI :: (string -> string);

external undefined :: undefined;

//hax until arrays act like objects:
external push :: forall a . Array<a>, a ->;
external sort :: forall a . Array<a>, (a, a -> int) -> Array<a>;
external Array_length :: forall a. Array<a> -> int;

//DOM stuff:
type DOMString :: string;
type Node :: rec Node . {
    ELEMENT_NODE :: int,
    ATTRIBUTE_NODE :: int,
    TEXT_NODE :: int,
    CDATA_SECTION_NODE :: int,
    ENTITY_REFERENCE_NODE :: int,
    ENTITY_NODE :: int,
    PROCESSING_INSTRUCTION_NODE :: int,
    COMMENT_NODE :: int,
    DOCUMENT_NODE :: int,
    DOCUMENT_TYPE_NODE :: int,
    DOCUMENT_FRAGMENT_NODE :: int,
    NOTATION_NODE :: int,
    nodeName :: DOMString,
    nodeValue :: DOMString,
    nodeType :: int,
    parentNode :: Node,
    //childNodes :: NodeList,
    firstChild :: Node,
    lastChild :: Node,
    previousSibling :: Node,
    nextSibling :: Node,
    //attributes :: NamedNodeMap,
    //ownerDocument :: Document,
    insertBefore :: (Node, Node -> Node),
    replaceChild :: (Node, Node -> Node),
    removeChild :: (Node -> Node),
    appendChild :: (Node -> Node),
    hasChildNodes :: ( -> bool),
    cloneNode :: (bool -> Node)
};

type Element :: { //Node (<-) {
    tagName :: DOMString,
    getAttribute :: (DOMString -> DOMString),
    setAttribute :: (DOMString, DOMString -> undefined),
    removeAttribute :: (DOMString -> undefined),
    /*getAttributeNode :: (DOMString -> Attr),
    setAttributeNode :: (Attr -> Attr),
    removeAttributeNode :: (Attr -> Attr),
    getElementsByTagName :: (DOMString -> NodeList),*/
    normalize :: ( -> undefined)
};
type HTMLElement :: rec self .{ //Element (<-) {
    id :: DOMString,
    title :: DOMString,
    lang :: DOMString,
    dir :: DOMString,
    className :: DOMString,

    //in javascript, but not the idl:
    innerHTML :: string,

    //copied from Node, and modified:
    appendChild :: ([self] self -> self),
    removeChild :: ([self] self -> self),

    //from prototype:
    setStyle :: ([self] {} -> self),
    setOpacity :: ([self] U(string, double) -> self),


};

type Document :: { //Node (<-) {
    /*doctype :: DocumentType,
    implementation :: DOMImplementation,*/
    documentElement :: Element,
    createElement :: (DOMString -> Element),
    /*createDocumentFragment :: ( -> DocumentFragment),
    createTextNode :: (DOMString -> Text),
    createComment :: (DOMString -> Comment),
    createCDATASection :: (DOMString -> CDATASection),
    createProcessingInstruction :: (DOMString, DOMString -> ProcessingInstruction),
    createAttribute :: (DOMString -> Attr),
    createEntityReference :: (DOMString -> EntityReference),
    getElementsByTagName :: (DOMString -> NodeList)*/
};

type HTMLDocument :: { //Document (<-) {
    title :: DOMString,
    referrer :: DOMString,
    domain :: DOMString,
    URL :: DOMString,
    body :: HTMLElement,
    /*images :: HTMLCollection,
    applets :: HTMLCollection,
    links :: HTMLCollection,
    forms :: HTMLCollection,
    anchors :: HTMLCollection,*/
    cookie :: DOMString,
    open :: ( -> undefined),
    close :: ( -> undefined),
    write :: (DOMString -> undefined),
    writeln :: (DOMString -> undefined),
    /*getElementById :: (DOMString -> Element),
    getElementsByName :: (DOMString -> NodeList)*/
};

external document :: HTMLDocument;




//stuff from flapjax, temporarily added here to make testfest work
type FlapjaxElement :: {};
external makeFJE :: (-> FlapjaxElement); //total hax

//change the following once we have *dicts* and *varargs*
/*external A :: ({className :: string, href :: string}, HTMLElement ->
               FlapjaxElement);*/
external A :: (U(HTMLElement, string)... ->
               FlapjaxElement);
/*external DIV :: (U(HTMLElement, string)... ->
                 FlapjaxElement);*/
external DIV :: (U(HTMLElement, string) -> //should be varargs
                 HTMLElement);
external DIV2 :: (U(HTMLElement, string),U(HTMLElement, string) ->
                 HTMLElement);
external DIV3 :: (U(HTMLElement, string),U(HTMLElement, string),
                  U(HTMLElement, string) ->
                 HTMLElement);
external TEXTAREA :: (HTMLElement -> HTMLElement);

type Pulse :: {stamp :: int, value :: {}}; //value should be parametrized
type SendT :: (Pulse -> );
type UpdaterT :: (SendT, Pulse -> );

type Behavior :: {}; //fill in later

//external internal_e :: (Array<EventStream>? -> EventStream);
type EventStream :: rec self . {updater :: UpdaterT, //not sure if send here
                     sendsTo :: Array<self>,
                     rank :: int,
                     lift_e :: (forall a b . ((a -> b) -> self)),
                     constant_e :: (any -> self),
                     sendEvent :: ([self] {} ->), //{} here should be 'value'
                                //not sure if sendEvent is in all eventstrems...
                     filter_e :: (forall a. ((a -> bool) -> self)),
                     startsWith :: (forall a. a -> Behavior)
                     };
external createNode :: (Array<EventStream>, UpdaterT -> EventStream);
external receiver_e :: (-> EventStream);
external merge_e :: (Array<EventStream> -> EventStream);

external extractEvent_e :: (Behavior, string -> EventStream);

external insertDomE :: (EventStream, U(string, HTMLElement), string? ->
                        EventStream); //bug in api docs: return type not given

//AJAX
type XMLHttpRequest :: rec self . {readyState :: int,
                        responseText :: DOMString,
                        responseXML :: Document,
                        status :: int,
                        statusText :: DOMString,
                        abort :: ([self] ->),
                        //more stuff goes here
};

//Prototype
external String_prototype_evalJSON :: (string, bool -> {}); //TODO: blah eval!!!
external $F :: (HTMLElement -> U(string, Array<string>));
external $Fs :: (HTMLElement -> string); //guaranteed one-string version of $F

//prototype:
external Array_each :: forall a. Array<a>, (a -> ) ->;

//hax until [] works:
external ES :: EventStream;
external HE :: HTMLElement;

//hax until modules work. this is defined in index.html, but
//tourney.tjs uses it:
external clicks_e :: (HTMLElement -> EventStream);
//stuff in tourney that index.html uses:
external server_e :: (string, EventStream -> EventStream);
external LINK :: U(HTMLElement, string) -> HTMLElement;
external modal :: (
  HTMLElement, EventStream, int? -> EventStream);

external Date_prototype_formatRelative :: (Date -> string);
external isSuccess :: {success :: bool} -> bool;

//types that tourney uses in particular. move to top of that file
//once they can be parsed up there
type AsgnT :: {
  id :: string,
  desc :: string,
  enabled :: bool,
  endtime :: int,
  singletestsuite :: bool,
  solncmd :: string,
  testcmd :: string,
  solnid :: string,
  solnlang :: string,
  testlang :: string};
type TestInfoT :: {
  time :: int,
  status :: {
    stat :: string,
    message :: string}};

/*maybe testinfot is really:
 * type TestInfoT :: {
  time :: int,
  userid :: string,
  asgnid :: string,
  singlesuite :: bool,
  status :: {
    stat :: string,
    message :: string}};
 */