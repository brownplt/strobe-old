//every type must only include types before it
//only bool, int, string, are given. (Also, Array for now is given)
//everything in here should automatically be recursve
// it should really be all mutually recursive


//methods of Array should go here

//constructors should go here; can't do that, yet.
//we can have certain types, though:
type RegExp :: {global :: bool,
                ignoreCase :: bool,
                lastIndex :: int,
                multiline :: bool,
                source :: string,
                exec :: (string -> Array<string>),
                test :: (string -> bool)};
//all this is missing is what to do when you say "new RegExp".

type String :: rec self . {length :: int,
                match :: ([self] string -> Array<string>?)};

/*
type String :: {length :: int,
                charAt :: ,
                charCodeAt :: ,
                concat :: ,
                indexOf:: ,
                lastIndexOf :: ,
                localCompare :: ,
                match :: ,
                replace :: ,
                search :: ,
                slice :: ,
                split :: ,
                substr :: ,
                substring :: ,
                toLowerCase :: ,
                toUpperCase :: ,
*/

//'static' methods of Date:
external Date :: {parse :: (string -> int),
                  UTC :: (int, int, int?, int?, int?, int?, int? -> int)};
type Date :: rec self . {getDay :: ([self] -> int),
                         getMonth :: ([self] -> int),
                         getYear :: ([self] -> int),
                         getFullYear :: ([self] -> int),
                         getHours :: ([self] -> int),
                         getMinutes :: ([self] -> int),
                         getDate :: ([self] -> int),
                        };

external decodeURI :: (string -> string);

external undefined :: undefined;

//hax to get testfest to work:
type DOMString :: string;
type Node :: rec Node . {
    ELEMENT_NODE :: int,
    ATTRIBUTE_NODE :: int,
    TEXT_NODE :: int,
    CDATA_SECTION_NODE :: int,
    ENTITY_REFERENCE_NODE :: int,
    ENTITY_NODE :: int,
    PROCESSING_INSTRUCTION_NODE :: int,
    COMMENT_NODE :: int,
    DOCUMENT_NODE :: int,
    DOCUMENT_TYPE_NODE :: int,
    DOCUMENT_FRAGMENT_NODE :: int,
    NOTATION_NODE :: int,
    nodeName :: DOMString,
    nodeValue :: DOMString,
    nodeType :: int,
    parentNode :: Node,
    //childNodes :: NodeList,
    firstChild :: Node,
    lastChild :: Node,
    previousSibling :: Node,
    nextSibling :: Node,
    //attributes :: NamedNodeMap,
    //ownerDocument :: Document,
    insertBefore :: (Node, Node -> Node),
    replaceChild :: (Node, Node -> Node),
    removeChild :: (Node -> Node),
    appendChild :: (Node -> Node),
    hasChildNodes :: ( -> bool),
    cloneNode :: (bool -> Node)
};

type Element :: { //Node (<-) {
    tagName :: DOMString,
    getAttribute :: (DOMString -> DOMString),
    setAttribute :: (DOMString, DOMString -> undefined),
    removeAttribute :: (DOMString -> undefined),
    /*getAttributeNode :: (DOMString -> Attr),
    setAttributeNode :: (Attr -> Attr),
    removeAttributeNode :: (Attr -> Attr),
    getElementsByTagName :: (DOMString -> NodeList),*/
    normalize :: ( -> undefined)
};
type HTMLElement :: rec self .{ //Element (<-) {
    id :: DOMString,
    title :: DOMString,
    lang :: DOMString,
    dir :: DOMString,
    className :: DOMString,
    //copied from Node, and modified:
    appendChild :: ([self] self -> self),
    removeChild :: ([self] self -> self),

    //from prototype:
    setStyle :: ([self] {} -> self),
    setOpacity :: ([self] U(string, double) -> self),


};

type Document :: { //Node (<-) {
    /*doctype :: DocumentType,
    implementation :: DOMImplementation,*/
    documentElement :: Element,
    createElement :: (DOMString -> Element),
    /*createDocumentFragment :: ( -> DocumentFragment),
    createTextNode :: (DOMString -> Text),
    createComment :: (DOMString -> Comment),
    createCDATASection :: (DOMString -> CDATASection),
    createProcessingInstruction :: (DOMString, DOMString -> ProcessingInstruction),
    createAttribute :: (DOMString -> Attr),
    createEntityReference :: (DOMString -> EntityReference),
    getElementsByTagName :: (DOMString -> NodeList)*/
};

type HTMLDocument :: { //Document (<-) {
    title :: DOMString,
    referrer :: DOMString,
    domain :: DOMString,
    URL :: DOMString,
    body :: HTMLElement,
    /*images :: HTMLCollection,
    applets :: HTMLCollection,
    links :: HTMLCollection,
    forms :: HTMLCollection,
    anchors :: HTMLCollection,*/
    cookie :: DOMString,
    open :: ( -> undefined),
    close :: ( -> undefined),
    write :: (DOMString -> undefined),
    writeln :: (DOMString -> undefined),
    /*getElementById :: (DOMString -> Element),
    getElementsByName :: (DOMString -> NodeList)*/
};

external document :: HTMLDocument;




//stuff from flapjax, temporarily added here to make testfest work
type FlapjaxElement :: {};
external makeFJE :: (-> FlapjaxElement); //total hax
/*external A :: ({className :: string, href :: string}, HTMLElement ->
               FlapjaxElement);*/
external A :: (U(HTMLElement, string)... ->
               FlapjaxElement);
/*external DIV :: (U(HTMLElement, string)... ->
                 FlapjaxElement);*/
external DIV :: (U(HTMLElement, string) ->
                 HTMLElement);

type Pulse :: {stamp :: int, value :: {}}; //value should be parametrized
type SendT :: (Pulse -> );
type UpdaterT :: (SendT, Pulse -> );
/*type EventStream :: rec self . {updater :: UpdaterT,
                     sendsTo :: Array<self>,
                     rank :: int,
                     //lift_e :: (forall a b . ((a -> b) -> self)),
                     lift_e :: (({session :: string} -> ) -> self),
                     };*/

type Behavior :: {}; //fill in later

//external internal_e :: (Array<EventStream>? -> EventStream);
type EventStream :: rec self . {updater :: UpdaterT, //not sure if send here
                     sendsTo :: Array<self>,
                     rank :: int,
                     lift_e :: (forall a b . ((a -> b) -> self)),
                     constant_e :: (any -> self),
                     sendEvent :: ([self] {} ->), //{} here should be 'value'
                     filter_e :: ((any -> bool) -> self),
                     startsWith :: (forall a. a -> Behavior)
                     };
external createNode :: (Array<EventStream>, UpdaterT -> EventStream);
external receiver_e :: (-> EventStream);
external merge_e :: (Array<EventStream> -> EventStream);

external extractEvent_e :: (Behavior, string -> EventStream);
external clicks_e :: (HTMLElement -> EventStream);

//AJAX
type XMLHttpRequest :: rec self . {readyState :: int,
                        responseText :: DOMString,
                        responseXML :: Document,
                        status :: int,
                        statusText :: DOMString,
                        abort :: ([self] ->),
                        //more stuff goes here
};

//Prototype
external String_prototype_evalJSON :: (string, bool -> {}); //TODO: blah eval!!!

//hax until arrays act like objects:
external push :: forall a . Array<a>, a ->;

//hax until [] works:
external ES :: EventStream;
external HE :: HTMLElement;
