-- |Converts types to contracts.
module TypedJavaScript.Contracts
  ( toContract
  , toInterface
  , encapsulate
  , encapsulateTypedModule
  , getContractsLib
  ) where

import Text.ParserCombinators.Parsec.Pos (SourcePos, initialPos)
import qualified Data.Map as M
import System.FilePath

import Paths_TypedJavaScript -- generated by Cabal

import Language.JavaScript.Contracts (Contract (..), getContractLibraryPath,
  InterfaceItem (..), compile)
import TypedJavaScript.TypeChecker (Env)
import TypedJavaScript.Syntax (Type (..))
import qualified WebBits.JavaScript as JavaScript

-- |'toContract' assumes that the supplied type is closed and well-formed.
toContract :: Type SourcePos -> Contract
toContract (TFunc pos Nothing reqargs [] maybeVararg result _) =
  FunctionContract pos (map toContract reqargs) varargCtc (toContract result)
    where varargCtc = case maybeVararg of
                        Nothing -> Nothing
                        Just vararg -> Just (toContract vararg)
toContract (TId pos id) = 
  error $ "unbound identifier (" ++ show id ++ ") at " ++ show pos ++
          " while converting a type to a contract"
-- TODO: This should not be hard-coded.  Fix  when we enable
-- user-defined types. Also add nullable contract.
toContract (TApp pos constr args) = case (constr,args) of
  (TId _ "bool",[]) -> NamedContract pos "isBool"
  (TId _ "int",[]) -> NamedContract pos "isInt"
  (TId _ "string",[]) -> NamedContract pos "isString"
  (constr,args) -> error $ "toContract does not know " ++  show (constr,args)
--toContract (TNullable pos t) = FlatContract pos JavaScript
toContract x = error $ "toContract does not handle " ++ show x
--TODO: add arrayOf for objects with @[] in them.

-- |Converts a type environment (presumably, a top-level type-environment)
-- to a list of 'InterfaceItem's.
toInterface :: Env
            -> [InterfaceItem]
toInterface env = map toExport (M.toList env) where
  toExport (v,t) = InterfaceExport v (initialPos "TypedJavaScript.Contracts")
                                   (toContract t)

-- |Wraps a Typed JavaScript module (after type-erasure) with contracts. The
-- result is a single function-application statement.
encapsulate :: [JavaScript.Statement SourcePos] -- ^type-erased tJS
            -> Env -- ^environment (i.e. exports)
            -> [JavaScript.Statement SourcePos] -- ^contract library
            -> JavaScript.Statement SourcePos -- ^encapsulated module
encapsulate typeErasedStmts env contractLib = wrappedStmts where
  interface = toInterface env
  wrappedStmts = compile typeErasedStmts interface contractLib

getContractsLib = do
  contractLib <- getContractLibraryPath
  dataDir <- getDataDir
  let typedContractLib = dataDir</>"typedjs_contracts.js"
  contractLibStmts <- JavaScript.parseJavaScriptFromFile contractLib
  typedContractLibStmts <- JavaScript.parseJavaScriptFromFile typedContractLib
  return $ contractLibStmts ++ typedContractLibStmts

encapsulateTypedModule :: [JavaScript.Statement SourcePos]
                       -> Env
                       -> IO (JavaScript.Statement SourcePos)
encapsulateTypedModule typeErasedStmts env = do
  lib <- getContractsLib
  return $ encapsulate typeErasedStmts env lib
  
